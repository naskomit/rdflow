use dataflow_core::block::*;
use dataflow_core::system::{SystemStorage, SystemCounters};

pub struct Block<'a> {
  pub true_value: Parameter<'a, f64>,
  pub false_value: Parameter<'a, f64>,
  pub in1: Input<'a, bool>,
  pub out1: Output<'a, f64>,
}

impl<'a> Block<'a> {
  pub fn outputs(&self) -> OutputUpdate {
    OutputUpdate { out1: 
      if *self.in1 {
        *self.true_value 
      } else {
        *self.false_value
      }
    }
  }
}

/* BEGIN autogenerated code */
pub const SIZE: BlockSize = BlockSize {
  r_param: 2,
  b_in: 1,
  r_out: 1,
  ..BlockSize::new()
};
pub struct OutputUpdate {
  pub out1: f64
}

pub fn new<'a>(storage: &'a dyn SystemStorage, counters: &mut SystemCounters) -> Block<'a> {
  Block {
    true_value: Parameter::<f64>::new(storage, counters.next_r_param()).init(1.0),
    false_value: Parameter::<f64>::new(storage, counters.next_r_param()).init(0.0),
    in1: Input::new(storage),
    out1: Output::new(storage, counters.next_r_out()),
  }
}

impl<'a> ApplyOutputUpdate for Block<'a> {
  fn apply(&self) {
    let output = self.outputs();
    self.out1.set(output.out1);
  }
}

impl<'a> IBlock for Block<'a> {
  fn get_computation(&self) -> BlockComputation {
    BlockComputation::Functional(FunctionalBlockComputation {
      output_update_fn: OutputUpdateFunction { f: self }
   })
  }
}

/* END autogenerated code */